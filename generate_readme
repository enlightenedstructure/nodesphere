#!/usr/bin/env coffee
#
# Usage:
#   npm install
#   ./generate_readme.coffee > README.md

{
  indent
  log
  p
  pretty
  quote
  sane
  say
  sha384
} = require 'lightsaber'

Nodesphere = require './lib/core/nodesphere'

say """
# Nodesphere

Nodesphere is an interchange format for node networks. It has three primary objectives:

1. Create interoperability among graph visualization interfaces
2. Provide adaptors to connect these interfaces to personal data ecosystems, 
   including social network data, online drives, and ultimately, any public or private data
3. Abstract data storage and retrieval, allowing transitions 
   from traditional server & database systems toward secure, distributed public and private storage, 
   as these systems become practical and performant

## Philosophical

Everything we want to share is a graph, or more colloquially, a group of knowledge nodes; a sphere of nodes; a nodesphere.
Nodesphere is designed to help enable the curation, sharing, visualization, and navigation of all your graph data!

## Technical

Let's get down to the bare metal. A nodesphere is a graph, in a simple JSON format, with content-addressable nodes and edges.
The JSON has a deterministic order so that content addresses are always consistent: 

- Arrays of content IDs are sorted
- Objects are sorted by their keys

## Development

### Starting a Local server

```
npm install
npm start
```
    
### Deploying to Heroku

```
heroku create
git push heroku master
heroku open
```
    
### Coffeescript

If you are more familiar with Javascript than Coffeescript, 
you may like to continuously compile all Coffeescript to JS:

```
bin/watch-coffee
```

Generated Javascript files are in subdirs of `./tmp/js/`.  
Note that these are for training purposes only and are not used by the application.
  
"""






# say """
#   ## Saving a Graph

#   ### HTTP PUT request

#   For example, suppose you perform an HTTP `PUT`, with a json payload of nodes and edges:

#   """

# sphere = new Nodesphere()
# sphere.put_edge 'John Perry Barlow', 'published', 'A Declaration of Independence of Cyberspace'
# log indent sane sphere.to_json()

# say """

# The ID of each node can be any unique string.  In this case we use the hash of the node's sorted minified JSON.  For example:
  
# """

# subject      = 'John Perry Barlow'
# subject_id   = sha384 subject

# log indent sane subject_id

# say """

# is the hash of 
  
# """

# log indent quote subject

# say """

# And:
  
# """

# edges = sphere.edge_array()
# edge = edges[0]
# [edge_id, edge_json] = edge
# log indent sane edge_id

# say """

# is the hash of 
  
# """

# # log indent quote sane edge_json

# say """

# Note that the JSON is minified and sorted by keys.
  
# """

# ####

# sphere_packed =
#   nodes: 
#     [
#       subject_id
#       predicate_id
#       object_id
#     ]
#   edges: 
#     [
#       sha384 nodesphere_json edge
#     ]

# say """

# ### HTTP PUT response

# The expected response to the `PUT` request is one or more keys:

# """

# sphere_hash = sha384 nodesphere_json sphere_packed
# log indent sane pretty sha384: sphere_hash

# say """

# Where `#{sane sphere_hash}` is the hash of the JSON of the entire "packed" sphere:

# """

# log indent quote sane nodesphere_json sphere_packed

# say """

# Note that the array values are sorted, as well as the object keys.
  
# """
