// Generated by CoffeeScript 1.7.1
var canocial_json, forge, indent, log, main, minified_json_sorted_by_key, p, pretty, quote, sane, say, sha384, sha384hex, type, _ref;

forge = require('node-forge');

_ref = require('../light/lib/log'), log = _ref.log, p = _ref.p, pretty = _ref.pretty;

type = require('../light/lib/type');

main = function() {
  var edge, object, predicate, sphere, sphere_hash, sphere_packed, subject;
  say("# NodeSphere\n\nSimple GET and PUT operations for _nodespheres_, which are simply collections of nodes and links.\n\n## PUT\n\n### The PUT request\n\nFor example, suppose you perform an HTTP `PUT`, with a json payload of nodes and links:\n");
  sphere = {
    nodes: {},
    edges: {}
  };
  subject = 'John Perry Barlow';
  predicate = 'published';
  object = 'A Declaration of Independence of Cyberspace';
  sphere.nodes[sha384hex(canocial_json({
    content: subject
  }))] = {
    content: subject
  };
  sphere.nodes[sha384hex(canocial_json({
    content: predicate
  }))] = {
    content: predicate
  };
  sphere.nodes[sha384hex(canocial_json({
    content: object
  }))] = {
    content: object
  };
  edge = {
    subject: sha384hex(canocial_json({
      content: subject
    })),
    predicate: sha384hex(canocial_json({
      content: predicate
    })),
    object: sha384hex(canocial_json({
      content: object
    }))
  };
  sphere.edges[sha384hex(canocial_json(edge))] = edge;
  log(indent(sane(pretty(sphere))));
  say("\nThe ID of each node can be any unique string.  In this case we use the SHA-384 of the node's sorted minified JSON.  For example:\n    ");
  log(indent(sane(sha384hex(canocial_json({
    content: subject
  })))));
  say("\nis the SHA-384 of \n    ");
  log(indent(quote(canocial_json({
    content: subject
  }))));
  say("\nAnd:\n    ");
  log(indent(sane(sha384hex(canocial_json(edge)))));
  say("\nis the SHA-384 of \n    ");
  log(indent(quote(sane(canocial_json(edge)))));
  say("\nNote that the JSON is minified and sorted by keys.\n    ");
  sphere_packed = {
    nodes: [
      sha384hex(canocial_json({
        content: subject
      })), sha384hex(canocial_json({
        content: predicate
      })), sha384hex(canocial_json({
        content: object
      }))
    ],
    edges: [sha384hex(canocial_json(edge))]
  };
  say("\n### The PUT response\n\nThe expected response to the `PUT` request is one or more keys:\n");
  sphere_hash = sha384hex(canocial_json(sphere_packed));
  log(sane(pretty({
    sha384: sphere_hash
  })));
  say("\nWhere, for example, `" + (sane(sphere_hash)) + "` is the SHA-384 of the JSON of the entire \"packed\" sphere:\n");
  log(indent(quote(sane(canocial_json(sphere_packed)))));
  return say("\nNote that the array values are sorted, as well as the object keys.\n    ");
};

say = function(text) {
  var line, _i, _len, _ref1, _results;
  _ref1 = text.split("\n");
  _results = [];
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    line = _ref1[_i];
    _results.push(log(line.trim()));
  }
  return _results;
};

indent = function(text, line_prefix) {
  var line, lines;
  if (line_prefix == null) {
    line_prefix = '    ';
  }
  lines = (function() {
    var _i, _len, _ref1, _results;
    _ref1 = text.split("\n");
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      line = _ref1[_i];
      _results.push("" + line_prefix + line);
    }
    return _results;
  })();
  return lines.join("\n");
};

sane = function(text, size) {
  if (size == null) {
    size = 8;
  }
  return text.replace(RegExp("\\b([0-9a-f]{" + size + "})[0-9a-f]{" + (384 / 4 - size) + "}\\b", "g"), "$1");
};

quote = function(text) {
  return "'" + text + "'";
};

canocial_json = minified_json_sorted_by_key = function(obj) {
  var key, pairs, val;
  pairs = (function() {
    var _i, _len, _ref1, _results;
    _ref1 = Object.keys(obj).sort();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      key = _ref1[_i];
      val = obj[key];
      if (type(val) === 'object') {
        throw "Error: Object depth of one expected";
      } else if (type(val) === 'array') {
        _results.push("" + (JSON.stringify(key)) + ":" + (JSON.stringify(val.sort())));
      } else {
        _results.push("" + (JSON.stringify(key)) + ":" + (JSON.stringify(val)));
      }
    }
    return _results;
  })();
  return "{" + (pairs.join(',')) + "}";
};

sha384 = function(text) {
  var message_digest;
  message_digest = forge.md.sha384.create();
  message_digest.update(text, 'utf-8');
  return {
    message_digest: message_digest,
    hex: message_digest.digest().toHex()
  };
};

sha384hex = function(text) {
  return sha384(text).hex;
};

main();
